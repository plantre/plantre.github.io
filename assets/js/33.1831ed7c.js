(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{390:function(v,_,e){"use strict";e.r(_);var o=e(7),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("JVM内存模型（Java Virtual Machine Memory Model）是Java程序运行时的核心机制，涵盖内存区域划分、多线程交互规则及内存管理策略。以下从内存区域结构和并发内存模型（JMM）两个维度解析：")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("一、JVM内存区域划分\nJVM将内存划分为多个区域，按线程共享性分为线程私有区域和线程共享区域，具体结构如下：")]),v._v(" "),_("ol",[_("li",[v._v("线程私有区域\n• 程序计数器（PC Register）")])]),v._v(" "),_("p",[v._v("记录当前线程执行的字节码指令地址，线程切换时恢复执行位置。唯一不会发生内存溢出的区域。")]),v._v(" "),_("p",[v._v("• 虚拟机栈（JVM Stack）")]),v._v(" "),_("p",[v._v("存储方法调用的栈帧，包含局部变量表、操作数栈等信息。每个方法对应一个栈帧，栈深度过大会抛出"),_("code",[v._v("StackOverflowError")]),v._v("。")]),v._v(" "),_("p",[v._v("• 本地方法栈（Native Method Stack）")]),v._v(" "),_("p",[v._v("服务于JNI调用的本地方法（如C/C++代码），结构与虚拟机栈类似。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("线程共享区域\n• 堆（Heap）")])]),v._v(" "),_("p",[v._v("• 新生代：包括Eden区和两个Survivor区，存放新创建的对象，采用复制算法回收。")]),v._v(" "),_("p",[v._v("• 老年代：存放长期存活对象，使用标记-清除或标记-整理算法。")]),v._v(" "),_("p",[v._v("• 调优参数：通过"),_("code",[v._v("-Xms")]),v._v("（初始堆大小）和"),_("code",[v._v("-Xmx")]),v._v("（最大堆大小）控制容量。")]),v._v(" "),_("p",[v._v("• 方法区（Method Area）")]),v._v(" "),_("p",[v._v("JDK 8后由元空间（Metaspace）替代永久代，存储类元信息、常量池、静态变量等，使用本地内存动态扩展。")]),v._v(" "),_("p",[v._v("• 直接内存（Direct Memory）")]),v._v(" "),_("p",[v._v("通过"),_("code",[v._v("ByteBuffer.allocateDirect()")]),v._v("分配，绕过堆直接操作物理内存，提升I/O性能。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("二、Java内存模型（JMM）的核心特性\nJMM是并发编程的底层规范，解决多线程下的可见性、原子性和有序性问题：")]),v._v(" "),_("ol",[_("li",[v._v("三大核心问题\n• 可见性（Visibility）")])]),v._v(" "),_("p",[v._v("一个线程修改共享变量后，其他线程能立即感知。通过"),_("code",[v._v("volatile")]),v._v("、"),_("code",[v._v("synchronized")]),v._v("或"),_("code",[v._v("final")]),v._v("实现。")]),v._v(" "),_("p",[v._v("• 原子性（Atomicity）")]),v._v(" "),_("p",[v._v("操作不可分割，如"),_("code",[v._v("i++")]),v._v("需通过"),_("code",[v._v("synchronized")]),v._v("或CAS（如"),_("code",[v._v("AtomicInteger")]),v._v("）保证原子性。")]),v._v(" "),_("p",[v._v("• 有序性（Ordering）")]),v._v(" "),_("p",[v._v("禁止指令重排序，"),_("code",[v._v("volatile")]),v._v("通过内存屏障（Memory Barrier）限制编译器和处理器优化。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("关键技术机制\n• 锁与同步")])]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v("通过对象头的Mark Word实现锁升级（偏向锁→轻量级锁→重量级锁），保障同步块的原子性和可见性。")]),v._v(" "),_("p",[v._v("• volatile关键字")]),v._v(" "),_("p",[v._v("底层依赖CPU的"),_("code",[v._v("LOCK")]),v._v("指令，强制刷新主存数据并使其他线程缓存失效。")]),v._v(" "),_("p",[v._v("• CAS与原子类")]),v._v(" "),_("p",[v._v("通过"),_("code",[v._v("cmpxchg")]),v._v("指令（带"),_("code",[v._v("LOCK")]),v._v("前缀）实现无锁并发，解决ABA问题需结合"),_("code",[v._v("AtomicStampedReference")]),v._v("。")]),v._v(" "),_("p",[v._v("• 内存屏障")]),v._v(" "),_("p",[v._v("禁止特定指令重排序，如"),_("code",[v._v("LoadLoad")]),v._v("屏障确保读操作顺序性。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("三、内存管理策略与优化")]),v._v(" "),_("ol",[_("li",[v._v("分代回收策略\n• 新生代：采用复制算法，快速回收短期对象。")])]),v._v(" "),_("p",[v._v("• 老年代：使用标记-整理算法，减少内存碎片。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("内存分配优化\n• TLAB（线程本地分配缓冲区）")])]),v._v(" "),_("p",[v._v("在Eden区为每个线程分配独立内存块，避免全局锁竞争，提升分配效率。")]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("伪共享与缓存行"),_("br"),v._v("\n变量若共享同一缓存行（64字节），频繁失效会导致性能下降。可通过"),_("code",[v._v("@sun.misc.Contended")]),v._v("注解填充字节解决。")])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("总结\nJVM内存模型通过区域划分实现高效内存管理，通过JMM规范解决多线程并发问题。理解其结构（如堆、栈、方法区）和机制（如锁、volatile、CAS）是优化Java程序性能的关键。实际开发中需结合监控工具（如JVisualVM）分析内存使用，并通过参数调优（如堆大小、GC算法）提升稳定性。")])])}),[],!1,null,null,null);_.default=t.exports}}]);