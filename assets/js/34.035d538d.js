(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{391:function(v,_,e){"use strict";e.r(_);var o=e(7),n=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("JVM垃圾回收中的“道法术器”体系解析")]),v._v(" "),_("p",[_("strong",[v._v("一、道（原理与哲学）")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("自动内存管理的核心理念"),_("br"),v._v("\nJVM垃圾回收（GC）的本质是通过自动化管理内存生命周期，避免内存泄漏和溢出。其核心哲学是“无感知回收”，开发者无需手动管理对象内存，降低心智负担。"),_("br"),v._v("\n• 可达性分析算法：通过GC Roots（如虚拟机栈、静态变量等）构建引用链，判断对象是否存活。未被引用的对象标记为垃圾（如Object5、Object6、Object7在引用链外）。")]),v._v(" "),_("p",[v._v("• 分代假设：根据对象存活时间将堆划分为年轻代（Young Generation）和老年代（Old Generation），采用不同回收策略（如年轻代用复制算法，老年代用标记整理）。")])]),v._v(" "),_("li",[_("p",[v._v("引用强度的层次性"),_("br"),v._v("\n• 强引用（如"),_("code",[v._v("Object obj = new Object()")]),v._v("）：即使内存不足也不会被回收。")]),v._v(" "),_("p",[v._v("• 软引用/弱引用：分别在内存紧张时或下一次GC时回收，适用于缓存场景。")]),v._v(" "),_("p",[v._v("• 虚引用：仅用于对象回收时的系统通知。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("二、法（算法与策略）")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("经典垃圾回收算法"),_("br"),v._v("\n• 标记-清除：分两阶段扫描内存，标记不可达对象后清除。优点简单直接；缺点内存碎片化（如图3中的内存空洞）。")]),v._v(" "),_("p",[v._v("• 复制算法：将内存分为两半，存活对象复制到另一半后清空原区域。优点无碎片；缺点内存利用率低（仅50%）。")]),v._v(" "),_("p",[v._v("• 标记-整理：标记后移动存活对象至内存前端，解决碎片问题（如图5），但耗时较长。")])]),v._v(" "),_("li",[_("p",[v._v("分代收集的实践"),_("br"),v._v("\n• 年轻代：Eden区新对象快速分配，Survivor区通过复制算法筛选存活对象（如From/To区交替使用）。")]),v._v(" "),_("p",[v._v("• 老年代：采用标记整理或并发标记清除（CMS），减少长时间停顿。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("三、术（垃圾收集器实现）")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("按代划分的经典收集器"),_("br"),v._v("\n• Serial GC：单线程STW回收，适用于客户端或小内存场景。")]),v._v(" "),_("p",[v._v("• Parallel GC（吞吐量优先）：多线程并行回收，适合计算密集型任务。")]),v._v(" "),_("p",[v._v("• CMS：并发标记清除，减少停顿时间，但存在内存碎片问题（JDK9后废弃）。")])]),v._v(" "),_("li",[_("p",[v._v("新一代收集器"),_("br"),v._v("\n• G1（Garbage-First）：以Region为单元划分堆，优先回收垃圾最多的区域（Mixed GC模式），支持可预测停顿（如"),_("code",[v._v("-XX:MaxGCPauseMillis=200")]),v._v("）。")]),v._v(" "),_("p",[v._v("◦ Region设计：支持Eden、Survivor、Old和Humongous分区，解决大对象处理难题。")]),v._v(" "),_("p",[v._v("◦ RSet（记忆集）：记录跨代引用，避免全堆扫描（如老年代引用年轻代对象）。")]),v._v(" "),_("p",[v._v("• ZGC：基于染色指针和读屏障实现亚毫秒级停顿（<10ms），支持TB级堆内存（JDK15+生产可用）。")]),v._v(" "),_("p",[v._v("• Shenandoah：类似ZGC，但通过Brooks指针实现并发整理，适用于低延迟场景。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("四、器（工具与调优）")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("JVM参数配置"),_("br"),v._v("\n• 堆内存："),_("code",[v._v("-Xmx")]),v._v("（最大堆）、"),_("code",[v._v("-Xmn")]),v._v("（年轻代大小）。")]),v._v(" "),_("p",[v._v("• 收集器选择："),_("code",[v._v("-XX:+UseG1GC")]),v._v("（启用G1）、"),_("code",[v._v("-XX:+UseZGC")]),v._v("（启用ZGC）。")])]),v._v(" "),_("li",[_("p",[v._v("监控与诊断工具"),_("br"),v._v("\n• 命令行工具："),_("code",[v._v("jstat")]),v._v("（实时监控GC统计）、"),_("code",[v._v("jmap")]),v._v("（堆转储分析）、"),_("code",[v._v("jstack")]),v._v("（线程堆栈跟踪）。")]),v._v(" "),_("p",[v._v("• 图形化工具：JConsole、VisualVM（可视化堆内存与GC活动）。")]),v._v(" "),_("p",[v._v("• GC日志分析：通过"),_("code",[v._v("-XX:+PrintGCDetails")]),v._v("记录详细回收过程，结合工具（如GCViewer）优化停顿时间。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("总结与选型建议")])]),v._v(" "),_("p",[v._v("• 低延迟场景：优先选择G1、ZGC或Shenandoah。")]),v._v(" "),_("p",[v._v("• 高吞吐量场景：Parallel GC或G1的默认模式。")]),v._v(" "),_("p",[v._v("• 超大堆内存：ZGC（TB级）或分代ZGC（JDK21+）。")]),v._v(" "),_("p",[v._v("• 调优核心：通过监控工具分析GC日志，平衡吞吐量、延迟和内存占用（如调整Region大小、并发线程数）。")])])}),[],!1,null,null,null);_.default=n.exports}}]);