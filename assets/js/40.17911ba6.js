(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{397:function(v,_,t){"use strict";t.r(_);var r=t(7),p=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("OOM、内存泄漏与内存溢出的区别解析")]),v._v(" "),_("p",[_("strong",[v._v("1. 核心定义")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("概念")]),v._v(" "),_("th",[v._v("定义")]),v._v(" "),_("th",[v._v("关键特征")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("OOM（内存不足）")]),v._v(" "),_("td",[v._v("程序运行过程中因内存不足而触发的错误，表现为 "),_("code",[v._v("OutOfMemoryError")]),v._v(" 或系统强制终止进程。")]),v._v(" "),_("td",[v._v("是内存问题的最终结果，可能由内存泄漏或内存溢出导致。")])]),v._v(" "),_("tr",[_("td",[v._v("内存泄漏")]),v._v(" "),_("td",[v._v("程序申请内存后未正确释放，导致内存无法被重复利用。")]),v._v(" "),_("td",[v._v("内存占用随时间持续增长，长期积累会引发OOM。")])]),v._v(" "),_("tr",[_("td",[v._v("内存溢出")]),v._v(" "),_("td",[v._v("程序一次性申请的内存超过可用内存限制，或系统无法满足动态分配需求。")]),v._v(" "),_("td",[v._v("内存需求瞬间超过容量，常见于大对象加载或递归调用过深。")])])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("2. 核心区别")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("触发机制"),_("br"),v._v("\n• 内存泄漏：因代码逻辑缺陷导致内存无法回收（如未关闭资源、静态集合持有对象）。")]),v._v(" "),_("p",[v._v("• 内存溢出：因内存分配不合理或系统资源不足（如堆设置过小、递归调用过深）。")]),v._v(" "),_("p",[v._v("• OOM：是前两者的最终表现形式，属于错误结果而非原因。")])]),v._v(" "),_("li",[_("p",[v._v("时间特性"),_("br"),v._v("\n• 内存泄漏：渐进式消耗内存（如缓存未清理导致内存逐渐耗尽）。")]),v._v(" "),_("p",[v._v("• 内存溢出：突发性内存需求（如加载超大文件到内存）。")]),v._v(" "),_("p",[v._v("• OOM：可能由任一情况触发，但泄漏更易导致长期OOM。")])]),v._v(" "),_("li",[_("p",[v._v("影响范围"),_("br"),v._v("\n• 内存泄漏：常影响堆内存，但资源泄漏（如文件句柄未释放）也会导致系统级问题。")]),v._v(" "),_("p",[v._v("• 内存溢出：可能涉及堆、栈或元空间（如递归调用过深引发栈溢出）。")]),v._v(" "),_("p",[v._v("• OOM：覆盖所有内存区域（堆、栈、直接内存等）。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("3. 典型场景与案例")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("内存泄漏"),_("br"),v._v("\n• 示例：未关闭数据库连接导致连接池耗尽；静态Map缓存未清理。")]),v._v(" "),_("p",[v._v("• 特点：程序运行越久，内存占用越高，最终触发OOM。")])]),v._v(" "),_("li",[_("p",[v._v("内存溢出"),_("br"),v._v("\n• 示例：一次性加载10GB文件到堆内存；递归调用未设终止条件导致栈溢出。")]),v._v(" "),_("p",[v._v("• 特点：突发性内存需求超过系统上限，直接触发OOM。")])]),v._v(" "),_("li",[_("p",[v._v("OOM类型"),_("br"),v._v("\n• 堆溢出："),_("code",[v._v("java.lang.OutOfMemoryError: Java heap space")]),v._v("（对象过多或泄漏）。")]),v._v(" "),_("p",[v._v("• 元空间溢出："),_("code",[v._v("OutOfMemoryError: Metaspace")]),v._v("（类加载过多）。")]),v._v(" "),_("p",[v._v("• 栈溢出："),_("code",[v._v("StackOverflowError")]),v._v("（递归深度过大）。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("4. 关系与递进")]),v._v("\n• 内存泄漏 → 内存溢出 → OOM：")]),v._v(" "),_("p",[v._v("内存泄漏长期积累导致可用内存减少，最终无法满足正常需求，触发溢出和OOM。"),_("br"),v._v("\n• 独立触发路径：")]),v._v(" "),_("p",[v._v("内存溢出可能由一次性错误（如超大数组申请）直接导致，无需泄漏积累。")]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("5. 排查与解决策略")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("问题类型")]),v._v(" "),_("th",[v._v("排查工具")]),v._v(" "),_("th",[v._v("解决方向")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("内存泄漏")]),v._v(" "),_("td",[v._v("Eclipse MAT、VisualVM分析堆快照")]),v._v(" "),_("td",[v._v("修复未关闭的资源、清理静态集合、优化缓存策略。")])]),v._v(" "),_("tr",[_("td",[v._v("内存溢出")]),v._v(" "),_("td",[v._v("JVM参数监控（"),_("code",[v._v("jstat")]),v._v("、"),_("code",[v._v("jmap")]),v._v("）")]),v._v(" "),_("td",[v._v("调整堆大小（"),_("code",[v._v("-Xmx")]),v._v("）、优化递归逻辑、分页处理数据。")])]),v._v(" "),_("tr",[_("td",[v._v("OOM")]),v._v(" "),_("td",[v._v("GC日志分析、系统内存监控")]),v._v(" "),_("td",[v._v("结合泄漏和溢出方案，必要时升级硬件或改用低内存占用的数据结构。")])])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("总结")]),v._v("\n• OOM是内存问题的最终表现，内存泄漏是长期隐患，内存溢出是短期过载。")]),v._v(" "),_("p",[v._v("• 核心差异：泄漏是“忘记还篮子”，溢出是“篮子装不下”，OOM是“彻底没篮子可用”。")]),v._v(" "),_("p",[v._v("• 调优优先级：优先解决内存泄漏（因其隐蔽性更强），再优化内存分配策略。")])])}),[],!1,null,null,null);_.default=p.exports}}]);