(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{392:function(v,_,l){"use strict";l.r(_);var r=l(7),t=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Minor GC、Major GC、Young GC、Old GC的区别解析")]),v._v(" "),_("p",[v._v("在JVM的垃圾回收（GC）机制中，不同术语对应不同的回收区域和触发条件。以下从定义、作用区域、触发条件及算法特点四个维度进行详细区分：")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("一、核心概念对比")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("术语")]),v._v(" "),_("th",[v._v("定义")]),v._v(" "),_("th",[v._v("作用区域")]),v._v(" "),_("th",[v._v("触发条件")]),v._v(" "),_("th",[v._v("算法特点")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("Minor GC")]),v._v(" "),_("td",[v._v("针对新生代的垃圾回收，也称为Young GC。")]),v._v(" "),_("td",[v._v("新生代（Eden + Survivor）")]),v._v(" "),_("td",[v._v("Eden区内存不足时触发。")]),v._v(" "),_("td",[v._v("复制算法（存活对象复制到Survivor区）")])]),v._v(" "),_("tr",[_("td",[v._v("Major GC")]),v._v(" "),_("td",[v._v("通常指Old GC，即老年代垃圾回收；但部分资料将其等同于Full GC。")]),v._v(" "),_("td",[v._v("老年代")]),v._v(" "),_("td",[v._v("老年代空间不足（如晋升对象过多或大对象直接分配失败）。")]),v._v(" "),_("td",[v._v("标记-清除或标记-整理算法（如CMS）")])]),v._v(" "),_("tr",[_("td",[v._v("Full GC")]),v._v(" "),_("td",[v._v("全局垃圾回收，覆盖整个堆（新生代+老年代）及方法区（元空间）。")]),v._v(" "),_("td",[v._v("全堆")]),v._v(" "),_("td",[v._v("老年代无法容纳晋升对象、方法区空间不足、显式调用"),_("code",[v._v("System.gc()")]),v._v("等。")]),v._v(" "),_("td",[v._v("标记-整理算法（如Serial Old）")])]),v._v(" "),_("tr",[_("td",[v._v("Mixed GC")]),v._v(" "),_("td",[v._v("G1收集器特有，同时回收新生代和部分老年代Region。")]),v._v(" "),_("td",[v._v("新生代+部分老年代")]),v._v(" "),_("td",[v._v("老年代占用达到阈值（默认45%）时触发。")]),v._v(" "),_("td",[v._v("分Region回收，优先处理垃圾最多区域")])])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("二、关键区别与常见误区")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Young GC与Minor GC的等价性"),_("br"),v._v("\n• Young GC和Minor GC是同一概念的不同命名，均针对新生代，触发条件是Eden区满。例如，当Eden区无法分配新对象时，触发Young GC，存活对象会被复制到Survivor区，年龄达到阈值（默认15次）后晋升到老年代。")])]),v._v(" "),_("li",[_("p",[v._v("Major GC的语义模糊性"),_("br"),v._v("\n• Major GC通常指老年代回收（即Old GC），但部分文档（如《深入理解Java虚拟机》）将其与Full GC混用。例如，CMS收集器的Major GC仅回收老年代，而Parallel Old收集器的Major GC可能隐含Full GC。")])]),v._v(" "),_("li",[_("p",[v._v("Full GC的触发复杂性"),_("br"),v._v("\n• Full GC的触发场景多样，包括：")]),v._v(" "),_("p",[v._v("◦ 老年代空间不足以容纳晋升对象。")]),v._v(" "),_("p",[v._v("◦ 方法区（元空间）内存不足（JDK 8前为永久代）。")]),v._v(" "),_("p",[v._v("◦ 显式调用"),_("code",[v._v("System.gc()")]),v._v("（不保证立即执行）。")]),v._v(" "),_("p",[v._v("• 性能影响：Full GC会暂停所有用户线程（STW），停顿时间可达秒级，需尽量避免。")])]),v._v(" "),_("li",[_("p",[v._v("Mixed GC的优化逻辑"),_("br"),v._v("\n• G1收集器的Mixed GC通过分Region回收策略，动态选择新生代和部分老年代进行回收，避免全堆扫描。例如，当老年代占用45%时，G1会触发Mixed GC以平衡吞吐量和延迟。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("三、实际应用中的注意事项")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("术语使用规范"),_("br"),v._v("\n• 在讨论GC类型时，需明确上下文。例如：")]),v._v(" "),_("p",[v._v("◦ CMS的Major GC仅指老年代回收。")]),v._v(" "),_("p",[v._v("◦ G1的Mixed GC不属于Full GC。")])]),v._v(" "),_("li",[_("p",[v._v("调优方向"),_("br"),v._v("\n• 减少Full GC频率：")]),v._v(" "),_("p",[v._v("◦ 增大老年代空间（"),_("code",[v._v("-Xmx")]),v._v("参数）。")]),v._v(" "),_("p",[v._v("◦ 避免大对象直接进入老年代（"),_("code",[v._v("-XX:PretenureSizeThreshold")]),v._v("）。")]),v._v(" "),_("p",[v._v("• 优化晋升策略：")]),v._v(" "),_("p",[v._v("◦ 调整晋升年龄阈值（"),_("code",[v._v("-XX:MaxTenuringThreshold")]),v._v("）。")]),v._v(" "),_("p",[v._v("◦ 监控Survivor区容量，避免过早晋升。")])]),v._v(" "),_("li",[_("p",[v._v("收集器选择"),_("br"),v._v("\n• 高吞吐场景：Parallel Scavenge + Parallel Old。")]),v._v(" "),_("p",[v._v("• 低延迟场景：G1或ZGC（停顿时间<10ms）。")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("总结\n• Minor GC/Young GC：高频、快速的新生代回收。")]),v._v(" "),_("p",[v._v("• Major GC/Old GC：低频、耗时的老年代回收，需注意术语歧义。")]),v._v(" "),_("p",[v._v("• Full GC：全局回收，代价最高，需优先规避。")]),v._v(" "),_("p",[v._v("• Mixed GC：G1特有的混合回收模式，兼顾新生代和老年代效率。")]),v._v(" "),_("p",[v._v("通过合理配置JVM参数（如"),_("code",[v._v("-Xmn")]),v._v("调整新生代大小）和选择垃圾收集器，可显著优化GC性能。具体调优建议可结合GC日志分析工具（如GCEasy）进一步排查。")])])}),[],!1,null,null,null);_.default=t.exports}}]);