(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{450:function(r,e,v){"use strict";v.r(e);var _=v(7),l=Object(_.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[r._v("Kafka 的分区确实采用了类似主从节点的设计机制，但其核心逻辑与传统的主从架构不同："),e("strong",[r._v("主从关系是以分区为粒度，而非整个集群或 Broker 节点")]),r._v("。以下是详细解析：")]),r._v(" "),e("h3",{attrs:{id:"📌-1-主副节点的本质-leader-follower-模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#📌-1-主副节点的本质-leader-follower-模式"}},[r._v("#")]),r._v(" 📌 1. "),e("strong",[r._v("主副节点的本质（Leader-Follower 模式）")])]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("每个分区（Partition）独立选举 Leader")]),e("br"),r._v("\nKafka 的 Topic 被划分为多个分区，每个分区有多个副本（Replica），副本分布在不同的 Broker 上。其中：\n"),e("ul",[e("li",[e("strong",[r._v("Leader 副本")]),r._v("：负责处理该分区的所有读写请求（生产者的写入和消费者的读取）。")]),r._v(" "),e("li",[e("strong",[r._v("Follower 副本")]),r._v("：仅从 Leader 同步数据，不对外提供服务。")])])]),r._v(" "),e("li",[e("strong",[r._v("Broker 节点角色动态变化")]),e("br"),r._v("\n同一 Broker 可能同时是某些分区的 Leader 和另一些分区的 Follower，例如：\n"),e("ul",[e("li",[r._v("Broker 1 是 Topic A 分区 1 的 Leader，但可能是 Topic B 分区 2 的 Follower。")]),r._v(" "),e("li",[r._v("这种设计避免了传统主从架构中“主节点单点瓶颈”问题。")])])])]),r._v(" "),e("h3",{attrs:{id:"⚡-2-主节点选举与故障切换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#⚡-2-主节点选举与故障切换"}},[r._v("#")]),r._v(" ⚡ 2. "),e("strong",[r._v("主节点选举与故障切换")])]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("选举范围")]),r._v("：当 Leader 副本失效（如 Broker 宕机），会从该分区的 "),e("strong",[r._v("ISR（In-Sync Replicas）")]),r._v(" 列表中选择新的 Leader。\n"),e("ul",[e("li",[e("strong",[r._v("ISR 定义")]),r._v("：与 Leader 数据同步延迟在阈值内（"),e("code",[r._v("replica.lag.time.max.ms")]),r._v("）的 Follower 副本。")])])]),r._v(" "),e("li",[e("strong",[r._v("容错策略")]),r._v("：\n"),e("ul",[e("li",[r._v("若 ISR 为空（所有 Follower 均不同步），且配置 "),e("code",[r._v("unclean.leader.election.enable=false")]),r._v("，分区将不可用（避免数据丢失）。")]),r._v(" "),e("li",[r._v("若配置为 "),e("code",[r._v("true")]),r._v("，则从非同步副本选举，可能丢失未同步的消息。")])])])]),r._v(" "),e("h3",{attrs:{id:"🔄-3-数据同步机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#🔄-3-数据同步机制"}},[r._v("#")]),r._v(" 🔄 3. "),e("strong",[r._v("数据同步机制")])]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("Follower 拉取数据")]),r._v("：Follower 定期从 Leader 拉取消息（类似消费者），写入本地日志。")]),r._v(" "),e("li",[e("strong",[r._v("提交条件")]),r._v("：生产者发送的消息需被 Leader 和所有 ISR 副本写入，才视为“已提交”（Committed），此时消费者可见。")]),r._v(" "),e("li",[e("strong",[r._v("HW（高水位）")]),r._v("：定义消费者可读取的最大偏移量（Offset），取 ISR 中副本的最小同步位置。")])]),r._v(" "),e("h3",{attrs:{id:"💡-4-设计优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#💡-4-设计优势"}},[r._v("#")]),r._v(" 💡 4. "),e("strong",[r._v("设计优势")])]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("负载均衡")]),r._v("：读写压力分散到多个 Broker（不同分区的 Leader 分布不同）。")]),r._v(" "),e("li",[e("strong",[r._v("高可用")]),r._v("：单点故障仅影响部分分区，且可快速切换 Leader。")]),r._v(" "),e("li",[e("strong",[r._v("扩展性")]),r._v("：增加分区或 Broker 可横向提升吞吐量。")])]),r._v(" "),e("h3",{attrs:{id:"⚠️-注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#⚠️-注意事项"}},[r._v("#")]),r._v(" ⚠️ 注意事项")]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("配置建议")]),r._v("：\n"),e("ul",[e("li",[r._v("设置 "),e("code",[r._v("replication.factor ≥ 3")]),r._v("，确保每个分区有足够副本。")]),r._v(" "),e("li",[r._v("关闭 "),e("code",[r._v("unclean.leader.election.enable")]),r._v("（默认值），优先保障数据一致性。")])])]),r._v(" "),e("li",[e("strong",[r._v("监控 ISR")]),r._v("：若 Follower 频繁被踢出 ISR，需检查网络或磁盘性能。")])]),r._v(" "),e("blockquote",[e("p",[r._v("✅ "),e("strong",[r._v("总结")]),r._v("：Kafka 的“主副节点”实则是 "),e("strong",[r._v("分区级别的 Leader-Follower 副本关系")]),r._v("，通过动态维护 ISR 和 Leader 选举，在保障高可用的同时实现分布式负载均衡。与传统主从架构不同，其设计更贴合分布式系统的弹性需求。")])])])}),[],!1,null,null,null);e.default=l.exports}}]);