(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{395:function(v,l,_){"use strict";_.r(l);var r=_(7),e=Object(r.a)({},(function(){var v=this,l=v._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("Full GC时年轻代与老年代的行为解析")]),v._v(" "),l("p",[v._v("Full GC（全局垃圾回收）是Java虚拟机（JVM）中代价最高、影响最大的垃圾回收过程，涉及整个堆内存（年轻代、老年代）及方法区（永久代/元空间）的全面回收。以下从年轻代和老年代的行为特点、触发条件及优化方向三个维度展开说明：")]),v._v(" "),l("hr"),v._v(" "),l("p",[v._v("一、Full GC时年轻代的行为")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("暂停分配与全面回收"),l("br"),v._v("\n• 暂停新对象分配：Full GC期间，所有用户线程停止（STW），年轻代无法分配新对象，直至回收完成。")]),v._v(" "),l("p",[v._v("• 全面清理：年轻代的Eden区和Survivor区会被完全回收，存活对象可能直接晋升到老年代（若老年代空间足够），或触发更复杂的内存调整机制（如空间分配担保失败）。")]),v._v(" "),l("p",[v._v("• 算法选择：不同收集器对年轻代的处理方式不同。例如，G1收集器的Mixed GC会同时回收部分年轻代和老年代Region，而Parallel Old等收集器可能采用标记-整理算法统一处理。")])]),v._v(" "),l("li",[l("p",[v._v("晋升失败的连锁反应"),l("br"),v._v("\n• 若Full GC由年轻代晋升失败触发（如Survivor区无法容纳存活对象），年轻代在回收时会尝试将存活对象强制转移至老年代。若老年代空间不足，则会进一步触发Full GC循环，加剧性能问题。")])])]),v._v(" "),l("hr"),v._v(" "),l("p",[v._v("二、Full GC时老年代的行为")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("空间整理与碎片处理"),l("br"),v._v("\n• 标记-清除与整理：老年代通常采用标记-清除或标记-整理算法。例如，CMS收集器在Full GC时需处理因并发回收产生的内存碎片，而Parallel Old收集器通过整理提升内存连续性。")]),v._v(" "),l("p",[v._v("• 大对象与长期对象回收：老年代中的大对象（如缓存数据）和长期存活对象（如全局配置）会被识别并回收，释放连续内存空间。")])]),v._v(" "),l("li",[l("p",[v._v("触发条件的影响"),l("br"),v._v("\n• 空间不足：老年代内存不足是Full GC最常见的触发原因。例如，动态年龄判断导致Survivor区对象批量晋升，或元空间（Metaspace）耗尽间接引发老年代压力。")]),v._v(" "),l("p",[v._v("• 收集器特性：CMS收集器在并发模式失败（Concurrent Mode Failure）时需回退到Serial Old进行Full GC，此时老年代需同步处理年轻代与自身的回收，导致长时间停顿。")])])]),v._v(" "),l("hr"),v._v(" "),l("p",[v._v("三、优化方向与建议")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("减少Full GC触发频率"),l("br"),v._v("\n• 调整堆内存比例：通过"),l("code",[v._v("-Xmn")]),v._v("增大年轻代，避免过早晋升；通过"),l("code",[v._v("-XX:MaxTenuringThreshold")]),v._v("调整晋升年龄阈值。")]),v._v(" "),l("p",[v._v("• 规避大对象直接分配：使用"),l("code",[v._v("-XX:PretenureSizeThreshold")]),v._v("限制大对象直接进入老年代（仅适用于Serial/ParNew收集器）。")])]),v._v(" "),l("li",[l("p",[v._v("提升回收效率"),l("br"),v._v("\n• 选择低延迟收集器：G1或ZGC通过分Region回收和并发压缩技术，减少Full GC的全局停顿时间。")]),v._v(" "),l("p",[v._v("• 监控与调优：通过GC日志分析工具（如GCeasy、VisualVM）识别内存泄漏或碎片化问题，动态调整参数。")])])]),v._v(" "),l("hr"),v._v(" "),l("p",[v._v("总结\n• 年轻代：Full GC期间暂停分配并强制清理，存活对象可能直接晋升或触发回收失败循环。")]),v._v(" "),l("p",[v._v("• 老年代：需处理长期存活对象、碎片整理及空间担保机制，不同收集器的回收策略差异显著。")]),v._v(" "),l("p",[v._v("• 核心优化点：通过合理分代、选择收集器及动态监控，平衡内存分配与回收效率，避免Full GC对系统性能的冲击。")])])}),[],!1,null,null,null);l.default=e.exports}}]);